# 2장. 실행 컨텍스트
## 01. 실행 컨텍스트란?
- 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
- 스택을 생각하면 되는데, 최초에 전역 컨텍스트가 실행되고 메서드가 실행될때 마다 콜스택에 해당 메서드가 쌓인다고 생각하면 된다.
```js
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner();
    console.log(a); // 1
}
outer();
console.log(a); // 1
```
- 실행되는 순서를 보면, 전역 컨텍스트 -> outer -> inner 순서로 콜스택에 쌓인다고 생각하면 된다.
- 의아한점은 inner 메서드에서 a는 undefined이지만, outer에서는 1이라는 점

<br>

## 02. VariableEnvironment
- 담기는 내용은 `LexicalEnvironment`와 같음
  - 실행 컨텍스트를 생성할 때, `VariableEnvironment`에 정보를 먼저 담고, 이를 그대로 복사해서 `LexicalEnvironment`를 만든다.
- 이후에는 `LexicalEnvironment`를 활용한다.
- `VariableEnvironment`, `LexicalEnvironment`의 내부는 `environmentRecord`와 `outer-EnvironmentReference`로 구성되어 있다.
  - 초기화 과정 중에는 동일하고 이후 코드 진행에 따라 달라진다.

<br>

## 03. LexicalEnvironment
- `Lexical`은 `사전적인` 이라는 의미로 받아들이는게 가장 좋다.
  - 현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고, D를 참조하도록 구성되어 있다 처럼 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이다.

### environmentRecord와 호이스팅
- `environmentRecord`에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
- 컨텍스트를 구성하는 함수, 식별자 등을 쭉 훑으면서 순서대로 수집한다.
  - 수집을 다 했음에도, 아직 코드는 실행되기 전의 상태이다.
  - 실행되기 전임에도, 코드의 변수명들을 모두 알고 있게 되는 셈이다.
#### 그래서, 자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다 라고 이해해도 문제가 없다.
- 이것이 호이스팅이다.

```js
function a (x) {
    console.log(x);
    var x;
    console.log(x);
    var x = 2;
    console.log(x);
}
a(1)
```
- 1, undefined, 2 가 원래는 맞겠지만, 호이스팅을 생각해보자

<br>

### 1. 메서드의 인자로 넘긴 값은 x에 값을 할당하는 것과 같다
```js
function a (x) {
    var x = 1;
    console.log(x);
    var x;
    console.log(x);
    var x = 2;
    console.log(x);
}
a()
```
- 그래서 위와 같다고 생각하면 되고

<br>

### 2. 식별자에는 어떤 값이 할당될 것인지는 중요하지 않고, 어떤 식별자들이 있는지만 관심이 있다
```js
function a (x) {
    var x;
    var x;
    var x;

    x = 1;
    console.log(x);
    console.log(x);
    x = 2;
    console.log(x);
}
a()
```
- 그래서 위와 같다고 생각하면 된다.
- 그래서 1, 1, 2 가 나온다.

<br>

### 추가로 하나 더 살펴보자
```js
function a () {
    console.log(b);
    var b = 'bbb';
    console.log(b);
    function b () { }
    console.log(b);
}
a();
```
- 위 코드는 아래와 같다
```js
function a () {
    var b;
    function b () { }
    
    console.log(b);
    b = 'bbb';
    console.log(b);
    console.log(b);
}
a();
```
- 메서드는 전체를 끌어올린다.
```js
function a () {
    var b;
    var b = function b () { }
    
    console.log(b);
    b = 'bbb';
    console.log(b);
    console.log(b);
}
a();
```
- 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언된 변수에 함수를 할당한 것처럼 여길 수 있다.
- 그래서 위와 같다.
- 결과는 b함수, bbb. bbb 이다.

<br>

### 함수 선언문과 함수 표현식
```js
function a () {} // 함수 선언문, 함수명 a가 곧 변수명.
a(); // 실행 OK.

var b = function () {} // 익명 함수 표현식. 변수명 b가 곧 함수명.
b(); // 실행 OK.

var c = function d () {} // 기명 함수 표현식. 변수명은 c, 함수명은 d.
c(); // 실행 OK.
d(); // 에러
```
- 함수를 정의하는 3가지 방법
- 첫번째는 평소 많이 보던 방식이고
- 두번째는 생소하지만, 함수를 변수에 할당할 수 있네
- 세번째는 함수에 이름을 붙여서 이전에는 함수명을 잘 출력할 수 있어서 디버깅하기 유리했다고 한다.
  - 지금은 모든 브라우저가 익명 함수 표현식의 변수명도 할당해주고 있다.

<br>

### 변수는 선언부만 끌어올리고, 함수는 전체를 호이스팅한다는 것을 기억하고 아래 예제를 보자
```js
console.log(sum(1, 2));
console.log(multiply(3, 4));

function sum (a, b) { // 함수 선언문 sum
    return a + b;
}

var multiply = function (a, b) { // 함수 표현식 multiply
    return a * b;
}
```
- 위 코드를 호이스팅하면
```js
var sum = function sum (a, b) { // 함수 선언문은 전체를 호이스팅.
    return a + b;
};
var multiply; // 변수는 선언부만 끌어올림.

console.log(sum(1, 2));
console.log(multiply(3, 4));

multiply = function (a, b) { // 변수의 할당부는 원래 자리에 남겨둠.
    return a * b;
}
```
- sum은 정상적으로 출력이 될 것이고, multiply는 아직 변수로 인식하고 있기 때문에 에러 메시지가 나온다.

<br>

### 마지막에 선언된 함수가 기존의 함수를 덮어씌운다.
```js
console.log(sum(3, 4)); // 3 + 4 = 7

function sum (x, y) {
    return x + y;
}

var a = sum(1, 2); // 1 + 2 = 3


function sum(x, y) {
    return x + ' + ' + y + ' = ' + (x + y);
}

var c = sum(1, 2);
console.log(c);
```
- 이런식으로 코드가 구성되어있다면, 밑의 문자열로 출력하는 sum 함수만 남게되고 `var a`는 전혀 다른 값을 갖게 된다.
- 함수 표현식은 상대적으로 안전하니 꼭 필요하다면 함수 표현식을 쓰자

<br>

### 스코프, 스코프 체인
- 스코프 체인은 식별자의 유효범위를 안에서부터 바깥으로 검색해나가는 것
- A 안에 B 함수, B 함수 안에 C 함수를 선언한 경우
  - C의 outerEnvironmentReference는 B의 LexicalEnvironment를 참조한다
  - B의 outerEnvironmentReference는 A의 LexicalEnvironment를 참조한다
- 이처럼 선언 시점의 LexicalEnvironment를 찾아 올라가면 마지막에 전역 컨텍스트가 있을 것 
이런 구조적인 특징 때문에, 스코프 체인 상에서 **가장 먼저 발견된 식별자**에게만 접근할 수 있다.

```js
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner();
    console.log(a); // 1
}
outer();
console.log(a); // 1
```
- 위에서 처음 봤던 예제이다.
- 한번 왜 이렇게 나오는지 위의 설명대로 따라가보자

#### 전역 -> outer -> inner 순서대로 점차 스코프의 규모는 작아진다. 그러나, 스코프 체인을 타고 접근 가능한 수는 늘어나게된다.
- inner는 전역, outer, inner 모두 접근 가능한 것
- 물론 스코프 체인 상의 변수라도 무조건 접근 가능한 것은 아니다.