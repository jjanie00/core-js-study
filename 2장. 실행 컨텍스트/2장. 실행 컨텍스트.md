## 실행 컨텍스트

- 실행할 코드에 제공할 환경 정보들을 모아둔 객체
- 코드를 실행하는 원리
  : 동일한 환경 (전역 공간, eval, 같은 함수) 에 있는 코드들을 실행할 때 필요한 **환경 정보**를 모아 **컨텍스트**를 만들고, **Call Stack** 에 쌓은 후 가장 위에 있는 컨텍스트 관련 코드를 실행한다.
- 실행 컨텍스트를 만드는 방법은 대부분 **함수** 를 통해 이루어진다.
- _실행 컨텍스트가 활성화될 때**(함수가 실행, 즉 호출되는 시점)** JS 엔진은 이 컨텍스트를 실행하는 데에 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다._
  | V.E (Variable Environment) | 실행 컨텍스트를 만들 떄 환경 정보를 담는 공간 | 환경 레코드 (스냅샷)
  outer 참조 (스냅샷) |
  | --- | --- | --- |
  | L.E (Lexical Environment) | V.E 를 복사해서 만들고 함수를 실행할 때 내용이 변경될 수 있음 | 환경 레코드 (복사본)
  outer 참조 (복사본) |
  | This 바인딩 | 함수 호출 방법에 따라 달라지지만, 일반 함수 안에서 this 를 사용하면 this 에 전역 객체가 할당된다 | |
  - 변수 환경에서 렉시컬 환경을 복사하는 시점 : 실행 컨텍스트를 생성할 때

### 코드 실행 과정

```bash
// (1)
let a = 1
function outer(){
  function inner(){
    console.log(a);
    let a = 3 // (4)
  }
  inner(); // (3)
  console.log(a);
}
outer(); // (2)
console.log(a); // (5)
```

1. 처음 코드를 실행할 떄 **전역 컨텍스트가 콜스택에 담긴다
   (전역 컨텍스트는 자바스크립트 파일이 열리는 순간 활성화된다)**
2. (2)번에서 outer 함수를 호출하면 outer 실행 컨텍스트를 콜스택에 담는다.
   (최상위 컨텍스트가 outer 이므로 outer 관련 코드 = outer 함수 내부 코드를 실행한다)
3. (3) 번에서 inner 함수를 호출하면 inner 실행 컨텍스트를 콜스택에 담는다.
   (마찬가지로 최상위 컨텓스트가 inner 이므로 inner 함수 내부 코드를 실행)
4. (4)번 이후 inner 함수가 종료되면 inner 함수 실행 컨텍스트를 콜스택에서 제거한다.
5. (가장 최상위 컨텍스트가 outer 이므로) 마저 outer 함수 코드를 실행한다.
6. outer 함수 실행이 종료되면 outer 도 실행 컨텍스트에서 제거된다.
7. (가장 최상위 컨텍스트가 전역 컨텍스트이므로) (5)번에서 a를 출력하고 전역 컨텍스트도 콜스택에서 제거된다.

## 렉시컬 환경, 호이스팅, this

![image.png](attachment:b5ffca18-f8a1-4d0c-ac04-096eae83aa2e:image.png)

## 함수 선언문과 함수 표현식

```bash
// 함수 선언문
function foo(){
 ..
 }

 // 함수 표현식 (변수에 할당)
 // 익명 함수, 기명 함수
 const a = foo(){..}
```

- 함수 선언문 : `function` 정의부만 O, 별도 할당문이 없는 선언 방식
  → 반드시 함수명이 있어야
- 함수 표현식 : 정의한 `function` 을 별도 변수에 할당해서 선언하는 방식
  → 함수명이 없어도 ㄱㅊ → 익명 / 기명 함수 표현식으로 나뉨
  (일반적으로 함수 표현식 = 익명 함수 표현식)
- 둘의 비교
  - 함수 선언문은 전체가 호이스팅 되서 선언 전에 호출할 수 있다.
    ![함수 선언문](attachment:d9f62e00-6ea4-4580-8d01-62920e085569:스크린샷_2025-10-25_오후_12.47.16.png)
    함수 선언문
  - 함수 표현식은 변수에 담긴 값이므로 변수 호이스팅처럼 동작한다.
    ![var 로 선언 (bar 에 undefined 가 담김 → 함수가 아니라는 에러가 남)](attachment:53fa490d-69b1-4c51-bb2f-945cb86fc657:스크린샷_2025-10-25_오후_12.47.24.png)
    var 로 선언 (bar 에 undefined 가 담김 → 함수가 아니라는 에러가 남)
    ![const 로 선언 (bar이 TDZ 존에 위치 → 초기화(할당) 이전에는 접근할 수 없다는 에러가 남)](attachment:f2bd4a4a-0755-459a-9142-2b807a548360:스크린샷_2025-10-25_오후_12.47.41.png)
    const 로 선언 (bar이 TDZ 존에 위치 → 초기화(할당) 이전에는 접근할 수 없다는 에러가 남)

## 스코프와 스코프 체인

- 스코프 : 식별자(변수, 함수)가 유효한 범위
- 스코프 체인 : outer 참조로 직전 실행 컨텍스트 참조와 연결되는 것
  (직전 실행 컨텍스트 = 상위 렉시컬 환경)

ES5 까지는 함수 스코프만 존재했지만, ES6 부터는 **블록 스코프** 라는 개념이 생겼다

![함수 스코프](attachment:fadf819f-c050-45f9-94b7-5e501058ca94:스크린샷_2025-10-25_오후_12.58.06.png)

함수 스코프

![블록 스코프 → 블록 안에서만 유효한 변수
({} 로 만들어지는 if, for 문 같은 스코프)](attachment:839fc2ec-346e-4a7c-a018-468779d03c88:스크린샷_2025-10-25_오후_12.57.53.png)

블록 스코프 → 블록 안에서만 유효한 변수
({} 로 만들어지는 if, for 문 같은 스코프)

(의문) 함수도 블록이므로, 함수 스코프도 블록 스코프에 해당된다고 볼 수 있지 않을까 ?
→ 함수도 블록이지만, 함수/블록 스코프는 역사적/ 기술적으로 다른 의미를 가진다.

- **함수 스코프** : var 이 인식하는 경계 (오직 함수만)
  → var 의 스코프 규칙
- **블록 스코프** : let, const 가 인식하는 경계 (모든 {})
  → let/const 의 스코프 규칙이자, 동작 방식을 설명하는 용어

(결론) 함수는 블록이 맞지만, 함수/블록 스코프는 **변수가 어떻게 동작하는지** 를 설명하는 용어

(교재) 여러 스코프에서 동일한 식별자를 선언한 경우, **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근** 할 수 있다.
→ outer 참조로 연결된 **바로 상위 스코프 (직전 실행 컨텍스트) 의 식별자**에 접근하므로
→ 스코프 체인을 따라가면서 outer 참조 로 연결된 상위 렉시컬 환경 - 환경 레코드 - 식별자에 접근

(추가)
코드 상에서 어떤 변수에 접근해야 할 때

- inner - 현재 컨텍스트의 렉시컬 환경을 먼저 탐색, 없으면
- outer - outer 참조와 연결된 상위 스코프 렉시컬 환경을 탐색 …
  전역 실행 컨텍스트까지 탐색 후 없으면 `ùndefined` 를 반환한다.
