## 1. 데이터 타입

- 데이터 타입은 기본형, 참조형으로 나눌 수 있다
  - 기본형 : 숫자, 문자열, 불리언, null / undefined, Symbol(ES6)
  - 참조형 : 객체. 배열, 함수, Date, 정규표현식, ES6 에서 추가된 Map, Set, …

## 2. 데이터 타입 배경 지식

- 정적 타입 언어(C, C++)는 메모리 낭비를 최소화하기 위해 데이터 타입 별로 할당할 메모리 영역을 정해둠
- 자바스크립트는 이런 규제에서 보다 자유로워서 메모리 공간을 더 넉넉하게 할당함
  (메모리 용량 증가, 숫자는 언제나 8byte 할당)
- 모든 데이터는 바이트로 표현될 수 있고 메모리 주솟값으로 구분될 수 있음
  - 각 비트는 고유한 식별자를 가진다
  - 바이트는 비트로 구성되있다. 즉, 시작하는 비트 식별자로 위치를 파악할 수 있다

## 3. 변수 선언과 데이터 할당

### **변수와 상수**

- 둘의 차이 : 데이터 할당이 이루어진 변수 공간에, 새 데이터를 재할당할 수 있는지의 여부
  (상수 : 재할당할 수 없는 변수)

### 변수 선언과 할당

- 변수 선언 : 컴퓨터가 메모리 빈 공간을 확보하고 식별자 이름을 붙인다.
  (+undefined 할당)
- 변수 할당 : 데이터 영역에 **값** 을 저장하고, 저장한 주소를 식별자가 저장된 변수 영역에 연결한다.
  - 기본형 데이터, 참조형 데이터 할당으로 나눌 수 있음

### 변수 할당의 분류

- 기본형 데이터 : 별도 공간에 데이터를 저장하고, 그 공간 주소를 변수의 값 영역에 할당한다.
- 참조형 데이터
  ![image.png](attachment:5e089285-b47d-4fa9-a652-af48d6cdb06c:image.png)
  1. 변수 (obj1) 를 저장하기 위한 빈 공간을 확보하고, 식별자를 저장
  2. 데이터를 저장해야지 → 여러 프로퍼티로 이루어진 데이터네 ?
  3. Key 를 저장하기 위한 빈 공간들을 확보하고, 그 주소들을 @5001에 저장
  4. Value 를 저장하기 위한 빈 공간을 확보, 그 주소들을 각각 (3)번 주소와 연결 (Value 가 메모리에 존재하는지 먼저 검색한 후)

### [추가 1] 참조 카운트

- 자신의 데이터 영역 주소를 참조하는 변수의 개수
  _(어떤 데이터를 참조하는 변수의 개수)_
- 참조 카운트가 0이 되면 가비지 컬렉터의 수거 대상이 됨

### [추가 2] 컴퓨터의 값 할당

- 메모리에서 먼저 해당 값이 있는지 검색 → 있으면 재활용 (주소) / 없으면 값을 저장할 데이터 공간을 만듬
- 한번 만들어진 값은 GC 에 의해 가비지 컬렉팅되지 않는 한, 사라지지 않음

## 4. 기본형 데이터와 참조형 데이터

### 참조형 데이터와 기본형 데이터의 차이

참조형 데이터는 **여러 개 프로퍼티(변수)를 모은 그룹**

### 참조형 데이터를 가변값으로 보는 이유

- 내부 프로퍼티를 변경하는 경우에 해당한다.
- key 를 변수로 볼 때, value 에 다른 값을 할당하면 key 에 연결되는 value 값이 변경된다. 즉, 데이터 영역에 저장하는 값들은 모두 불변이지만 key(변수) 에는 다른 값을 할당할 수 있다.

<aside>

객체 자체 주소와 데이터 영역 값들 모두 불변이지만,
프로퍼티(key) 가 가리키는 주소는 변경할 수 있다 → “가변” 의 이유
(원시값 : 변수가 직접 값의 주소를 가리키므로 재할당 외에는 변경할 수 x)

</aside>

참조형 데이터는 불변값처럼 사용하려면, 깊은 복사나 immer.js 같은 라이브러리를 이용할 수 있다.

### [추가] 불변값

- 데이터 영역에 저장된 메모리 그 자체
  → GC 가 정리하지 않는 한 변경될 수 X
- 기본형 데이터는 모두 불변값

## 5. 불변 객체

```ts
let user = {...}
let changeName = function (user, newName) {
  let newUser = user; // 이 경우
  ..
}
```

참조형 데이터는 가변적이지만, 불변성을 유지해야 하는 경우들이 있다
(값으로 전달 받은 객체에 변경을 주더라도, 원본 객체가 변경되지 않아야 하는 경우)

### 해결 방법 : 기존 객체 프로퍼티를 복사하는 함수

- 원본 객체 (user) 을 다룰 때는 이 함수를 사용한다는 규칙을 걸어둔다.
- immer.js, immutable.js .. : 규칙 자체를 시스템적 제약으로 걸어둔 라이브러리들
  _(라이브러리 자체에서 불변성을 가진 별도 데이터 타입과 메서드를 제공함)_
- 이를 통해 가변적인 객체를 불변 데이터처럼 이용할 수 있다 (불변 객체)

그 외에 깊은 복사를 이용하는 방법도 있음

## 5-1. 깊은 복사, 얕은 복사

- 깊은 복사 : 원본과 아예 독립적인 새로운 객체를 만든다
  (**중첩된 객체**까지 재귀적으로 모두 복사)
- 얕은 복사 : 내부 프로퍼티가 저장된 주소만 복사 (최상위 레벨만)

  ```ts
  const original = {
    name: "홍길동", // 원시값 프로퍼티
    address: {
      // 중첩 객체 프로퍼티
      city: "서울",
    },
  };

  const copy = { ...original }; // 얕은 복사

  copy.name = "김철수"; // 원시값 프로퍼티 변경 (원본 영항 x)
  copy.address.city = "부산"; // 중첩 객체 프로퍼티 변경 (원본 영향 o)
  ```

  - 얕은 복사는 최상위 레벨만 복사해오므로 원시값 프로퍼티를 변경해도, 별도 객체라 원본에 영향이 없다.
  - 중첩 객체 프로퍼티는 참조가 연결되있어서 → 값을 변경하면 원본 객체 값도 바뀐다.

## 6. undefined, null

### JS 엔진이 undefined 를 할당하는 상황

```ts
// 선언만 하고, 값을 할당하지 않은 변수에 접근하는 경우
let a;
console.log(a); // undefined

// 존재하지 않는 프로퍼티에 접근하는 경우
let obj = { a : 1 }
console.log(obj.b); // undefined

// return 문이 없는 함수를 실행하는 경우
let func = function(){..}
let a = func();
console.log(a); // undefined
```

### undefined, 배열

```ts
let emptyArr = new Array(3);
console.log(emptyArr); // [empty * 3]

let undefinedArr = [undefined, undefined, undefined];
console.log(undefinedArr); // [undefined, undefined, undefined]
```

- Array( ) 로 생성한 배열은 비어있다 (empty) ↔ 직접 undefined 를 할당한 배열
- 비어있는 요소는 배열 메서드의 순회 대상에서 제외되지만,
  사용자가 직접 지정한 undefined 는 **그 자체로 값** 이라 순회 가능하다.

### null, undefined

- **null** → 사용자가 직접 ‘값이 없음’ 을 표현할 때 사용하는 타입
  - 애초에 `undefined` 를 대체하기 위해 나온 타입
  - 특이하게, `typeof null` 은 object 라고 한다.
  - 즉, null 인지 판단할 때는 `===` 를 사용한다.
    ```bash
    let n = null;
    console.log(n === null); // true
    ```
- **undefined** → JS 엔진이 접근할 수 없는 값임을 표현할 때 사용하는 타입
